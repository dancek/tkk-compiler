/*
A Coco/R compiler definition for the following grammar:

Grammar -> MainFuncDecl

MainFuncDecl    -> main FuncBody

FuncBody        -> begin VarDecl StatementList ReturnStatement end
VarDecl         -> Type identifier ; VarDecl
VarDecl         ->
ReturnStatement -> return Expr ;

StatementList   -> Statement StatementList
StatementList   ->

Statement       -> if ( Expr ) then Statement 
Statement       -> for ( ForStatement ; Expr ; ForStatement ) Statement 
ForStatement    -> IdAccess <= Expr		// Meaning: assignment
ForStatement    -> 
Statement       -> print ( Expr ) ;
Statement       -> begin StatementList end
Statement       -> IdAccess <= Expr ;		// Meaning: assignment

Expr            -> BaseExpr op BaseExpr
Expr            -> ! BaseExpr
Expr            -> - BaseExpr
Expr            -> BaseExpr

BaseExpr        -> ( Expr )
BaseExpr        -> IdAccess
BaseExpr        -> integer
BaseExpr        -> true
BaseExpr        -> false
BaseExpr        -> read ( )

IdAccess        -> identifier

Type            -> int
Type            -> boolean
*/

import fi.tkk.cs.tkkcc.slx.SlxProgram;
import static fi.tkk.cs.tkkcc.slx.CommandWord.*;

// Set the name of your grammar here (and at the end of this grammar):
COMPILER Grammar

private Printer printer;
private SlxProgram slx;
private SymbolTable tab;

public Parser(Scanner s, Printer p) {
       this(s);
       this.printer = p;
       this.slx = new SlxProgram();
       this.tab = new SymbolTable();
}

public SlxProgram getSlx() {
	return this.slx;
}


// Add auxiliary methods and declaration here.


// If you want your generated compiler case insensitive add the
// keyword IGNORECASE here.


CHARACTERS
// Add character set declarations here.
// Examples:
//   cr = '\r'.
//   lf = '\n'.
letter = 'A'..'Z' + 'a'..'z'.
digit = "0123456789".


TOKENS
// Add token declarations here.
// Example:
//   ident = letter {letter | digit}.
//   number = digit {digit}.
op			= "+" | "*" | "/" | "<" | "&&" .
identifier	= letter { letter | digit } .
integer		= digit {digit} .

int         = "int".
boolean     = "boolean".

PRAGMAS
// Add pragma declarations here.
// Example:
//   switch = '$' { digit | letter }. (. Optional semantic action .)


// Add comments here.
// Example for a multi-line block comment:
//   COMMENTS FROM "/*" TO "*/" NESTED
// Example for a single line comment:
//   COMMENTS FROM "//" TO lf


// Set the ignored characters (whitespaces) here, the blank character is
// ignored by default.
// Example, add line breaks to the ignore set.
//   IGNORE cr + lf


PRODUCTIONS

// Add your productions here, one must have the same name as the grammar,
// it will be the start symbol (entry point of your compiler).
// Example:
//   Empty = "BEGIN" { Statement } "END".
//   Statement = ident "=" number { "+" number } .

Grammar	        = MainFuncDecl .

MainFuncDecl    =   (. printer.startProduction("MainFuncDecl"); .)
    "main"
    FuncBody
                    (. printer.endProduction(); .)                          .

FuncBody        =   (. printer.startProduction("FuncBody"); .)
    "begin"         
    VarDecl
    {Statement}
    ReturnStatement
    "end"           (. slx.emit(HLT); .)
                    (. printer.endProduction(); .)                          .

VarDecl         =   (. printer.startProduction("VarDecl"); .)
    Type
    identifier
    ";"
    [VarDecl]
                    (. printer.endProduction(); .)                          .

ReturnStatement =   (. printer.startProduction("ReturnStatement"); .)
    "return"
    Expr
    ";"
                    (. printer.endProduction(); .)                          .

Statement       =   (. printer.startProduction("Statement"); .)
    "if"
    "("
    Expr
    ")"
    "then"
    Statement 
 |
    "for"
    "("
    [ForStatement]
    ";"
    Expr
    ";"
    [ForStatement]
    ")"
    Statement
 | 
    "print"
    "("
    Expr
    ")"
    ";"
 | 
    "begin"
    {Statement}
    "end"
 | 
    IdAccess
    "<="
    Expr
    ";"
                    (. printer.endProduction(); .)                          .

ForStatement    =   (. printer.startProduction("ForStatement"); .)
    IdAccess
    "<="
    Expr
                    (. printer.endProduction(); .)                          .

Expr            =   (. printer.startProduction("Expr"); .)
    BaseExpr
    [
      (op | "-" )
      BaseExpr
    ]
 |
    "!"
    BaseExpr
 | 
    "-"
    BaseExpr 
.

BaseExpr        =   (. printer.startProduction("BaseExpr"); .)
    "("
    Expr
    ")"
 | 
    IdAccess
 | 
    integer
 |
    "true"
 |
    "false"
 |
    "read"
    "("
    ")"
                    (. printer.endProduction(); .)                          .

IdAccess        =   (. printer.startProduction("IdAccess"); .)
    identifier
                    (. printer.endProduction(); .)                          .

Type            =   (. printer.startProduction("Type"); .)
    int             (. printer.print("int"); .)
 |
    boolean
                    (. printer.endProduction(); .)                          .

// End of your compiler specification, make sure the name here matches
// the grammar name at the start of this grammar.
END Grammar.

