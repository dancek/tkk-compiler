/*
A Coco/R compiler definition for the following grammar:

Grammar -> MainFuncDecl

MainFuncDecl    -> main FuncBody

FuncBody        -> begin VarDecl StatementList ReturnStatement end
VarDecl         -> Type identifier ; VarDecl
VarDecl         ->
ReturnStatement -> return Expr ;

StatementList   -> Statement StatementList
StatementList   ->

Statement       -> if ( Expr ) then Statement 
Statement       -> for ( ForStatement ; Expr ; ForStatement ) Statement 
ForStatement    -> IdAccess <= Expr		// Meaning: assignment
ForStatement    -> 
Statement       -> print ( Expr ) ;
Statement       -> begin StatementList end
Statement       -> IdAccess <= Expr ;		// Meaning: assignment

Expr            -> BaseExpr op BaseExpr
Expr            -> ! BaseExpr
Expr            -> - BaseExpr
Expr            -> BaseExpr

BaseExpr        -> ( Expr )
BaseExpr        -> IdAccess
BaseExpr        -> integer
BaseExpr        -> true
BaseExpr        -> false
BaseExpr        -> read ( )

IdAccess        -> identifier

Type            -> int
Type            -> boolean
*/

import fi.tkk.cs.tkkcc.slx.SlxProgram;
import static fi.tkk.cs.tkkcc.slx.CommandWord.*;

// Set the name of your grammar here (and at the end of this grammar):
COMPILER Grammar

// boolean constants
private final int TRUE = 1;
private final int FALSE = 0;

private Printer printer;
private SlxProgram slx;
private SymbolTable tab;

private int nextAddr = 1; // a "sequence" of addresses

public Parser(Scanner s, Printer p) {
    this(s);
    this.printer = p;
    this.slx = new SlxProgram();
    this.tab = new SymbolTable();
}

public SlxProgram getSlx() {
    return this.slx;
}

public SymbolTable getSymbolTable() {
    return this.tab;
}


// Add auxiliary methods and declaration here.


// If you want your generated compiler case insensitive add the
// keyword IGNORECASE here.


CHARACTERS
// Add character set declarations here.
// Examples:
//   cr = '\r'.
//   lf = '\n'.
letter = 'A'..'Z' + 'a'..'z'.
digit = "0123456789".


TOKENS
// Add token declarations here.
// Example:
//   ident = letter {letter | digit}.
//   number = digit {digit}.
identifier	= letter { letter | digit } .
integer		= digit {digit} .


PRAGMAS
// Add pragma declarations here.
// Example:
//   switch = '$' { digit | letter }. (. Optional semantic action .)


// Add comments here.
// Example for a multi-line block comment:
//   COMMENTS FROM "/*" TO "*/" NESTED
// Example for a single line comment:
//   COMMENTS FROM "//" TO lf


// Set the ignored characters (whitespaces) here, the blank character is
// ignored by default.
// Example, add line breaks to the ignore set.
//   IGNORE cr + lf
IGNORE ' ' + '\t' + '\r' + '\n'


PRODUCTIONS

// Add your productions here, one must have the same name as the grammar,
// it will be the start symbol (entry point of your compiler).
// Example:
//   Empty = "BEGIN" { Statement } "END".
//   Statement = ident "=" number { "+" number } .

Grammar	        = MainFuncDecl .

MainFuncDecl        (. printer.startProduction("MainFuncDecl"); .)
  =
    "main"
    FuncBody        (. slx.emit(HLT); .)
                    (. printer.endProduction(); .)                          .

FuncBody            (. printer.startProduction("FuncBody"); .)
  =
    "begin"
    [VarDecl]
    {Statement}
    ReturnStatement
    "end"
                    (. printer.endProduction(); .)                          .

VarDecl             (. printer.startProduction("VarDecl"); .)
  =
    Type
    identifier      (. // add symbol to symbol table
                        int addr = nextAddr++;
                        tab.add(t.val, addr);
                    .)
    ";"
    [VarDecl]
                    (. printer.endProduction(); .)                          .

ReturnStatement     (. printer.startProduction("ReturnStatement"); .)
  =
    "return"
    Expr
    ";"
                    (. printer.endProduction(); .)                          .

Statement           (. printer.startProduction("Statement"); .)
  = (
    "if"
    "("
    Expr            (. // `Expr` value got pushed; if it's false, jump out of if
                        int bypass = nextAddr++;
                        slx.emit(JZE, bypass);
                    .)
    ")"
    "then"
    Statement       (. slx.emit(LAB, bypass); .)
  |
    "for"
    "("
    [Assignment]    // initial assignment happens first
    ";"             (. // we need four labels (see README)
                        int test = nextAddr++,
                            end = nextAddr++,
                            incr = nextAddr++,
                            loop = nextAddr++;
                        slx.emit(LAB, test); // label before loop test
                    .)
    Expr            (. // `Expr` value got pushed
                        slx.emit(JZE, end);     // false; jump out of for
                        slx.emit(JMP, loop);    // true; jump to loop body
                        
                        slx.emit(LAB, incr);    // the "incrementing" part
                    .)
    ";"
    [Assignment]
    ")"             (.
                        slx.emit(JMP, test); 
                        slx.emit(LAB, loop); // loop body
                    .)
    Statement       (. // end of loop; jump to "incrementing" part
                        slx.emit(JMP, incr);
                        slx.emit(LAB, end); // label for jumping out
                    .)
  | 
    "print"
    "("
    Expr
    ")"
    ";"             (. slx.emit(WRI); .)
  | 
    "begin"
    {Statement}
    "end"
  | 
    Assignment
    ";"
)                   (. printer.endProduction(); .)                          .


// Assignment used to be called ForStatement
Assignment          (. printer.startProduction("Assignment"); .)
  =
    IdAccess        // push(addr)
    "<="
    Expr            // push(val)
                    (. slx.emit(STL); .) // store `val` at `addr`
                    (. printer.endProduction(); .)                          .

Expr                (. printer.startProduction("Expr"); .)
  = (
    BaseExpr
    [
      "+" BaseExpr  (. slx.emit(ADD); .)  
    | "-" BaseExpr  (. slx.emit(SUB); .)  
    | "*" BaseExpr  (. slx.emit(MUL); .)  
    | "/" BaseExpr  (. slx.emit(DIV); .)  
    | "<" BaseExpr  (. slx.emit(RLT); .)  
    | "&&" BaseExpr (. // AND: Pop x. Pop y. Push x && y to stack.
                        int false1 = nextAddr++,
                            false2 = nextAddr++,
                            fin = nextAddr++;
                        slx.emit(JZE, false1);
                        slx.emit(JZE, false2);
                        // both TRUE so push(TRUE) and jump to `fin`
                        slx.emit(ENT, TRUE);
                        slx.emit(JMP, fin);
                        slx.emit(LAB, false1);  // first pop() false
                        // use JZE to pop another time
                        slx.emit(JZE, false2);
                        slx.emit(LAB, false2);  // false (two values popped)
                        slx.emit(ENT, FALSE);   // push(FALSE)
                        slx.emit(LAB, fin);     // finished!
                    .)
    ]
  |
    "!"
    BaseExpr        (. slx.emit(NOT); .)
  | 
    "-"
    BaseExpr        (. slx.emit(UMN); .)
)                   (. printer.endProduction(); .)                          .

BaseExpr            (. printer.startProduction("BaseExpr"); .)
  = (
    "("
    Expr
    ")"
  | 
    IdAccess        // push(addr)
                    (. slx.emit(LDL); .) // load from `addr`
  | 
    integer         (. slx.emit(ENT, Integer.parseInt(t.val)); .)
  |
    "true"          (. slx.emit(ENT, TRUE); .)
  |
    "false"         (. slx.emit(ENT, FALSE); .)
  |
    "read"
    "("
    ")"             (. slx.emit(REA); .) // read from stdin
)                   (. printer.endProduction(); .)                          .

IdAccess            (. printer.startProduction("IdAccess"); .)
  =
    identifier      (. // load variable address
                        int addr = tab.getAddress(t.val);
                        slx.emit(ENT, addr);
                    .)
                    (. printer.endProduction(); .)                          .

Type                (. printer.startProduction("Type"); .)
  = (
    "int"
  |
    "boolean"
)                   (. printer.endProduction(); .)                          .

// End of your compiler specification, make sure the name here matches
// the grammar name at the start of this grammar.
END Grammar.

