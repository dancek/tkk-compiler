/*
Grammar -> MainFuncDecl

MainFuncDecl    -> main FuncBody

FuncBody        -> begin VarDecl StatementList ReturnStatement end
VarDecl         -> Type identifier ; VarDecl
VarDecl         ->
ReturnStatement -> return Expr ;

StatementList   -> Statement StatementList
StatementList   ->

Statement       -> if ( Expr ) then Statement 
Statement       -> for ( ForStatement ; Expr ; ForStatement ) Statement 
ForStatement    -> IdAccess <= Expr		// Meaning: assignment
ForStatement    -> 
Statement       -> print ( Expr ) ;
Statement       -> begin StatementList end
Statement       -> IdAccess <= Expr ;		// Meaning: assignment

Expr            -> BaseExpr op BaseExpr
Expr            -> ! BaseExpr
Expr            -> - BaseExpr
Expr            -> BaseExpr

BaseExpr        -> ( Expr )
BaseExpr        -> IdAccess
BaseExpr        -> integer
BaseExpr        -> true
BaseExpr        -> false
BaseExpr        -> read ( )

IdAccess        -> identifier

Type            -> int
Type            -> boolean
*/

// Set the name of your grammar here (and at the end of this grammar):
COMPILER Grammar

private Printer printer;

public Parser(Scanner s, Printer p) {
       this(s);
       this.printer = p;
}


// Add auxiliary methods and declaration here.


// If you want your generated compiler case insensitive add the
// keyword IGNORECASE here.


CHARACTERS
// Add character set declarations here.
// Examples:
//   cr = '\r'.
//   lf = '\n'.
letter = 'A'..'Z' + 'a'..'z'.
digit = "0123456789".


TOKENS
// Add token declarations here.
// Example:
//   ident = letter {letter | digit}.
//   number = digit {digit}.
op			= "+" | "*" | "/" | "<" | "&&" .
identifier	= letter { letter | digit } .
integer		= digit {digit} .

PRAGMAS
// Add pragma declarations here.
// Example:
//   switch = '$' { digit | letter }. (. Optional semantic action .)


// Add comments here.
// Example for a multi-line block comment:
//   COMMENTS FROM "/*" TO "*/" NESTED
// Example for a single line comment:
//   COMMENTS FROM "//" TO lf


// Set the ignored characters (whitespaces) here, the blank character is
// ignored by default.
// Example, add line breaks to the ignore set.
//   IGNORE cr + lf


PRODUCTIONS

// Add your productions here, one must have the same name as the grammar,
// it will be the start symbol (entry point of your compiler).
// Example:
//   Empty = "BEGIN" { Statement } "END".
//   Statement = ident "=" number { "+" number } .

Grammar			= MainFuncDecl .

MainFuncDecl    = "main" FuncBody .

FuncBody        = "begin" [VarDecl] StatementList ReturnStatement "end" .
VarDecl         = Type identifier ";" [VarDecl] .
ReturnStatement = "return" Expr ";" .

StatementList   = Statement StatementList
				| .

Statement       = "if" "(" Expr ")" "then" Statement 
				| "for" "(" ForStatement ";" Expr ";" ForStatement ")" Statement
                | "print" "(" Expr ")" ";"
                | "begin" StatementList "end"
                | IdAccess "<=" Expr ";" .
ForStatement    = IdAccess "<=" Expr
                |  .

Expr            = BaseExpr [ ( op | "-" ) BaseExpr ]
                | "!" BaseExpr
                | "-" BaseExpr .

BaseExpr        = "(" Expr ")"
                | IdAccess
                | integer
                | "true"
                | "false"
                | "read" "(" ")" .

IdAccess        = identifier .

Type            = "int"
                | "boolean" .

// End of your compiler specification, make sure the name here matches
// the grammar name at the start of this grammar.
END Grammar.

